import re
import logging
from typing import List, Dict, Any, Tuple, Optional

logger = logging.getLogger(f"pipeline.{__name__}")

def flatten_whisperx_transcript(transcript_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Converts the nested WhisperX-like transcript structure into a flat list of individual words.

    The input `transcript_data` is expected to be a list of segment dictionaries,
    where each segment contains a 'words' key, which is itself a list of word dictionaries.
    Each word dictionary is expected to have 'word', 'start', and 'end' keys.

    This function iterates through all segments and extracts their 'words' lists,
    combining them into a single, flat list. It also ensures that each word string
    is stripped of leading/trailing whitespace for consistency.

    Args:
        transcript_data (List[Dict[str, Any]]): The raw transcript data, typically parsed
                                                 from a JSON file, structured as a list of
                                                 segment dictionaries.

    Returns:
        List[Dict[str, Any]]: A flattened list of word dictionaries. Each dictionary
                              in the returned list will contain 'word' (str), 'start' (float),
                              and 'end' (float) keys, representing the word's text and its
                              absolute start and end timestamps in the original audio/video.
    """
    all_words: List[Dict[str, Any]] = []
    for segment in transcript_data:
        # Ensure 'words' key exists and is not None before extending
        if 'words' in segment and segment['words'] is not None:
            all_words.extend(segment['words'])
    
    # Strip whitespace from each word for cleaner processing downstream
    for word_info in all_words:
        if 'word' in word_info and isinstance(word_info['word'], str):
            word_info['word'] = word_info['word'].strip()
    
    logger.debug(f"Flattened transcript into {len(all_words)} words.")
    return all_words

def find_phrase_in_transcription(
    transcription_words: List[Dict[str, Any]],
    phrase_to_find: str
) -> Tuple[Optional[float], Optional[float]]:
    """
    Finds the start and end time of a specific text phrase within a flat list of transcribed words.

    This function performs a case-insensitive search and ignores common punctuation
    (commas, periods, question marks, exclamation marks) when matching the phrase.
    It iterates through the `transcription_words` list using a sliding window
    approach to find the exact sequence of words that matches the `phrase_to_find`.

    Args:
        transcription_words (List[Dict[str, Any]]): A flat list of word dictionaries,
                                                     typically generated by `flatten_whisperx_transcript`.
                                                     Each dictionary must contain 'word', 'start', and 'end' keys.
        phrase_to_find (str): The exact text phrase to search for within the transcript.

    Returns:
        Tuple[Optional[float], Optional[float]]: A tuple containing two floats:
                                                 (start_timestamp, end_timestamp) of the found phrase.
                                                 Returns (None, None) if the phrase is not found or is invalid.
    """
    # TODO: The phrase cleaning regex is simple. It could be enhanced to handle more complex cases,
    # such as normalizing hyphenated words or expanding contractions (e.g., "it's" -> "it is")
    # to make the phrase matching more robust and less prone to missing a match.
    # Clean the phrase to find: remove punctuation and convert to lowercase
    clean_phrase: str = re.sub(r'[\s.,?!]+', ' ', phrase_to_find).lower().strip()
    phrase_words: List[str] = clean_phrase.split()

    if not phrase_words:
        logger.warning(f"Phrase '{phrase_to_find}' is empty or invalid after cleaning. Skipping search.")
        return None, None

    num_phrase_words: int = len(phrase_words)
    num_transcription_words: int = len(transcription_words)

    # Iterate through the transcription words with a sliding window
    for i in range(num_transcription_words - num_phrase_words + 1):
        # Extract a window of words from the transcript for comparison
        window_dicts: List[Dict[str, Any]] = transcription_words[i : i + num_phrase_words]
        
        # Validate that all words in the window have the necessary 'word' key and are strings
        if not all('word' in w and isinstance(w['word'], str) for w in window_dicts):
            logger.debug(f"Skipping window at index {i} due to invalid word data.")
            continue

        # Clean the words in the current window for comparison
        window_words: List[str] = [re.sub(r'[\s.,?!]+', ' ', w['word']).lower().strip() for w in window_dicts]

        # Compare the cleaned window words with the cleaned phrase words
        if window_words == phrase_words:
            # If a match is found, retrieve the start time of the first word and end time of the last word
            # Ensure 'start' and 'end' keys exist before accessing
            if 'start' in transcription_words[i] and 'end' in transcription_words[i + num_phrase_words - 1]:
                phrase_start_time: float = transcription_words[i]['start']
                phrase_end_time: float = transcription_words[i + num_phrase_words - 1]['end']
                logger.info(f"ðŸŽ¯ Found phrase '{phrase_to_find}' from {phrase_start_time:.2f}s to {phrase_end_time:.2f}s.")
                return phrase_start_time, phrase_end_time
            else:
                logger.warning(f"Found phrase '{phrase_to_find}' but missing start/end timestamps for words in window {i}.")
                return None, None

    logger.info(f"Phrase '{phrase_to_find}' not found in the transcription.")
    return None, None